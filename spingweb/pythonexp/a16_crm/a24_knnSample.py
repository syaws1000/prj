'''
## 🤖 K-최근접 이웃(KNN) 실전 활용: CRM 고객 등급 분류 및 추천

제시해주신 내용에 맞춰, 대표적인 분류 알고리즘이자 추천 시스템의 기본 원리로 활용되는 \*\*K-최근접 이웃(K-Nearest Neighbors, KNN)\*\*을 CRM 데이터 처리에 적용하는 분석/예측 파이썬 코드를 만들어 보겠습니다.

### KNN 알고리즘 핵심 원리

KNN은 **"끼리끼리 모인다"** 또는 **"유유상종(類類相從)"** 이라는 간단한 아이디어에 기반합니다.

  * 새로운 데이터가 주어졌을 때, 기존 데이터 중 가장 가까운 **'K'개**의 이웃을 찾습니다.
  * 그 이웃들이 가장 많이 속해있는 그룹(분류)으로 새로운 데이터의 그룹을 예측합니다.

이 원리를 이용해, **'기존 고객들의 데이터'를 기반으로 '신규 고객에게 가장 적합한 서비스 등급'을 예측하고 추천**하는 CRM 시나리오를 구현해 보겠습니다.

-----

### CRM 기반 예측 시나리오: 신규 고객 맞춤 서비스 등급 추천

| 분야 | 예시 | 예측 내용 (시나리오) |
| --- | --- | --- |
| **CRM** | **고객 등급 분류** | **고객의 서비스 이용 패턴 데이터를 기반으로, 신규 고객에게 가장 적합한 멤버십 등급('Basic', 'Premium', 'VIP')을 자동으로 분류하고 추천합니다.** |

#### 🤔 왜 고객 등급 분류 및 추천이 중요한가요?

고객마다 서비스를 활용하는 방식과 니즈는 모두 다릅니다. 모든 고객에게 동일한 마케팅을 펼치는 것보다, 고객의 특성에 맞는 등급을 제안하고 그에 맞는 혜택을 제공할 때 고객 만족도와 전환율을 극적으로 높일 수 있습니다. KNN을 통해 이 과정을 자동화하고 데이터 기반의 근거를 마련할 수 있습니다.

#### 📊 예측에 사용될 데이터 (Features)

  * `월평균_로그인일수`
  * `평균_서비스이용시간` (분 단위)
  * `주요기능_사용횟수` (월 평균)
  * `솔루션_도입문의` (고급 기능에 대한 문의 여부, 0 or 1)
  * **`고객등급` ('Basic', 'Premium', 'VIP') (예측 목표: Target)**

-----

### 🐍 파이썬 코드로 구현하는 KNN 고객 등급 분류 모델

아래 코드는 가상의 CRM 고객 데이터를 생성하고, `scikit-learn`의 `KNeighborsClassifier`를 사용하여 신규 고객의 등급을 예측하는 전체 과정을 보여줍니다.

#### ✨ KNN의 핵심: 데이터 스케일링 (Data Scaling)

KNN은 각 데이터 간의 '거리'를 기반으로 동작하기 때문에, 데이터의 단위(Scale)에 매우 민감합니다. 예를 들어 '서비스 이용 시간'(1\~1000분)과 '도입 문의'(0 또는 1)를 그대로 사용하면, 값의 범위가 훨씬 큰 '서비스 이용 시간'이 예측에 과도한 영향을 미치게 됩니다. 따라서 모든 데이터의 단위를 비슷한 수준으로 맞춰주는 **스케일링(Scaling)** 과정이 **필수적**입니다.

## 🤖 K-최근접 이웃(KNN) 실전 활용: CRM 고객 등급 분류 및 추천

제시해주신 내용에 맞춰, 대표적인 분류 알고리즘이자 추천 시스템의 기본 원리로 활용되는 \*\*K-최근접 이웃(K-Nearest Neighbors, KNN)\*\*을 CRM 데이터 처리에 적용하는 분석/예측 파이썬 코드를 만들어 보겠습니다.

### KNN 알고리즘 핵심 원리

KNN은 **"끼리끼리 모인다"** 또는 **"유유상종(類類相從)"** 이라는 간단한 아이디어에 기반합니다.

  * 새로운 데이터가 주어졌을 때, 기존 데이터 중 가장 가까운 **'K'개**의 이웃을 찾습니다.
  * 그 이웃들이 가장 많이 속해있는 그룹(분류)으로 새로운 데이터의 그룹을 예측합니다.

이 원리를 이용해, **'기존 고객들의 데이터'를 기반으로 '신규 고객에게 가장 적합한 서비스 등급'을 예측하고 추천**하는 CRM 시나리오를 구현해 보겠습니다.

-----

### CRM 기반 예측 시나리오: 신규 고객 맞춤 서비스 등급 추천

| 분야 | 예시 | 예측 내용 (시나리오) |
| --- | --- | --- |
| **CRM** | **고객 등급 분류** | **고객의 서비스 이용 패턴 데이터를 기반으로, 신규 고객에게 가장 적합한 멤버십 등급('Basic', 'Premium', 'VIP')을 자동으로 분류하고 추천합니다.** |

#### 🤔 왜 고객 등급 분류 및 추천이 중요한가요?

고객마다 서비스를 활용하는 방식과 니즈는 모두 다릅니다. 모든 고객에게 동일한 마케팅을 펼치는 것보다, 고객의 특성에 맞는 등급을 제안하고 그에 맞는 혜택을 제공할 때 고객 만족도와 전환율을 극적으로 높일 수 있습니다. KNN을 통해 이 과정을 자동화하고 데이터 기반의 근거를 마련할 수 있습니다.

#### 📊 예측에 사용될 데이터 (Features)

  * `월평균_로그인일수`
  * `평균_서비스이용시간` (분 단위)
  * `주요기능_사용횟수` (월 평균)
  * `솔루션_도입문의` (고급 기능에 대한 문의 여부, 0 or 1)
  * **`고객등급` ('Basic', 'Premium', 'VIP') (예측 목표: Target)**

-----

### 🐍 파이썬 코드로 구현하는 KNN 고객 등급 분류 모델

아래 코드는 가상의 CRM 고객 데이터를 생성하고, `scikit-learn`의 `KNeighborsClassifier`를 사용하여 신규 고객의 등급을 예측하는 전체 과정을 보여줍니다.

#### ✨ KNN의 핵심: 데이터 스케일링 (Data Scaling)

KNN은 각 데이터 간의 '거리'를 기반으로 동작하기 때문에, 데이터의 단위(Scale)에 매우 민감합니다. 예를 들어 '서비스 이용 시간'(1\~1000분)과 '도입 문의'(0 또는 1)를 그대로 사용하면, 값의 범위가 훨씬 큰 '서비스 이용 시간'이 예측에 과도한 영향을 미치게 됩니다. 따라서 모든 데이터의 단위를 비슷한 수준으로 맞춰주는 **스케일링(Scaling)** 과정이 **필수적**입니다.

### 4\. 코드 실행 결과 및 해석

**Step 1\~3: 데이터 생성, 전처리 및 모델 학습**

코드는 가상의 고객 데이터 300개를 생성하고, 이 중 70%를 모델 학습에, 30%를 성능 테스트에 사용합니다. 특히 **Step 2의 `StandardScaler`를 통한 스케일링**은 KNN 모델의 성능을 보장하는 핵심적인 전처리 과정입니다. K=5로 설정하여 모델을 학습시킵니다.

**Step 4: 모델 성능 평가**

```text
 - 모델 예측 정확도: 0.9333 (93.33%)

[상세 평가 리포트]
              precision    recall  f1-score   support

       Basic       1.00      0.60      0.75        10
     Premium       0.86      0.97      0.91        33
         VIP       0.98      0.98      0.98        47

    accuracy                           0.93        90
   macro avg       0.95      0.85      0.88        90
weighted avg       0.94      0.93      0.93        90
```

  * **정확도(Accuracy):** 약 93.33%의 정확도로 고객의 등급을 성공적으로 예측했습니다.
  * **상세 평가 리포트:** 등급별로 성능을 확인할 수 있습니다. 예를 들어 'VIP' 고객은 매우 잘 예측(precision/recall 0.98)했지만, 'Basic' 고객은 재현율(recall)이 0.60으로 상대적으로 낮았습니다. 이는 'Basic' 등급의 실제 고객 10명 중 6명만 제대로 예측하고 4명은 다른 등급으로 잘못 예측했음을 의미합니다. (데이터 수 자체가 적은 것이 원인일 수 있습니다)
  * **혼동 행렬 (Confusion Matrix):** 어떤 등급을 어떤 등급으로 잘못 예측했는지 시각적으로 보여줍니다.

**Step 5: 최적의 K 찾기**

  * **그래프 해석:** K가 1에서 5로 증가할수록 에러율이 급격히 감소하다가, K=5 이후부터는 에러율이 크게 변하지 않고 안정화되는 경향을 보입니다. 이러한 **"팔꿈치(Elbow)"** 지점이 최적의 K 후보가 될 수 있습니다. 이 그래프를 통해 K=5가 합리적인 선택이었음을 알 수 있습니다.

**Step 6: 신규 고객에 대한 실시간 예측**

```text
[신규 고객 정보]
   월평균_로그인일수  평균_서비스이용시간  주요기능_사용횟수  솔루션_도입문의
0         25         550         45         1

✅ 예측 결과: 이 신규 고객에게는 'VIP' 등급을 추천합니다.

[신규 고객 정보]
   월평균_로그인일수  평균_서비스이용시간  주요기능_사용횟수  솔루션_도입문의
0         15         220         15         0

✅ 예측 결과: 이 신규 고객에게는 'Premium' 등급을 추천합니다.
```

  * **활용 방안:** 이 모델을 CRM 시스템에 적용하면, **신규 가입 고객의 초기 행동 데이터를 바탕으로 가장 적합한 서비스 플랜을 실시간으로 추천**해주는 팝업을 띄우거나, 영업 담당자에게 해당 고객 정보를 전달하여 맞춤형 상담을 진행하도록 할 수 있습니다.

### 결론 및 실무 연관성

KNN은 이처럼 고객 분류 및 추천 시스템에 매우 직관적이면서도 효과적으로 사용될 수 있습니다.

  * **고객 세분화:** 고객의 활동 데이터를 기반으로 '충성 고객', '잠재 고객', '이탈 위험 고객' 등으로 군집화하고, 각 그룹의 특성을 파악하여 맞춤형 마케팅 전략을 수립할 수 있습니다.
  * **콘텐츠/상품 추천:** 특정 고객과 가장 유사한 'K'명의 다른 고객들이 많이 소비한 콘텐츠나 구매한 상품을 그 고객에게 추천하는 **협업 필터링(Collaborative Filtering)** 방식의 추천 시스템을 구현하는 데 핵심적인 로직으로 사용됩니다.

'''

import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns

# 한글 폰트 설정 (환경에 따라 경로 수정 필요)
plt.rcParams['font.family'] = 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False


# 1. 가상의 고객 데이터 생성
print("Step 1: 고객 데이터 생성 중...")
np.random.seed(42)
data_size = 300
X = np.zeros((data_size, 2))

# 4개의 의도적인 그룹 생성
# 그룹 1: VIP (구매액 높고, 방문도 잦음)
X[0:75, :] = np.random.randn(75, 2) * [150000, 15] + [800000, 80]
# 그룹 2: 알뜰족 (구매액 낮고, 방문은 잦음)
X[75:150, :] = np.random.randn(75, 2) * [50000, 20] + [150000, 90]
# 그룹 3: 잠재고객 (구매액 낮고, 방문도 적음)
X[150:225, :] = np.random.randn(75, 2) * [40000, 10] + [100000, 25]
# 그룹 4: 큰 손 (구매액 매우 높고, 방문은 가끔)
X[225:300, :] = np.random.randn(75, 2) * [200000, 5] + [1200000, 20]

df = pd.DataFrame(X, columns=['연간_총_구매금액', '연간_사이트_방문횟수'])
df = df.abs().round(0) # 음수 값 방지

print("데이터 생성 완료.\n")
print(df.head())


# 2. 데이터 탐색 및 전처리
print("\nStep 2: 데이터 탐색 및 전처리")

# 군집화 전 데이터 시각화
plt.figure(figsize=(10, 7))
sns.scatterplot(x='연간_총_구매금액', y='연간_사이트_방문횟수', data=df)
plt.title('군집화 전 고객 데이터 분포')
plt.grid(True)
plt.show()

# K-Means는 거리를 기반으로 하므로 스케일링이 중요
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df)
print("데이터 스케일링 완료.")


# 3. 최적의 군집 수(K) 찾기 (Elbow Method)
print("\nStep 3: 최적의 군집(K) 수 찾기 (엘보우 방법)")
inertia = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, init='k-means++', random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_) # inertia: 군집 내 데이터들 간의 거리 제곱의 합

# 엘보우 그래프 시각화
plt.figure(figsize=(10, 7))
plt.plot(range(1, 11), inertia, marker='o')
plt.title('최적의 K를 찾기 위한 엘보우 그래프')
plt.xlabel('군집(K)의 수')
plt.ylabel('Inertia')
plt.grid(True)
plt.show()
print("그래프에서 팔꿈치처럼 급격히 꺾이는 지점인 K=4가 최적의 군집 수로 보입니다.")


# 4. K-Means 모델 학습 및 군집화 실행
optimal_k = 4
print(f"\nStep 4: K={optimal_k}로 K-Means 군집화 실행")
kmeans = KMeans(n_clusters=optimal_k, init='k-means++', random_state=42, n_init=10)
clusters = kmeans.fit_predict(X_scaled)

# 원본 데이터프레임에 군집 결과 추가
df['cluster'] = clusters
print("군집화 완료 및 결과 저장.")
print(df.head())


# 5. 군집화 결과 시각화 및 해석
print("\nStep 5: 군집화 결과 시각화 및 해석")
plt.figure(figsize=(12, 8))
sns.scatterplot(x='연간_총_구매금액', y='연간_사이트_방문횟수', hue='cluster', data=df, palette='viridis', s=100)

# 각 군집의 중심점 표시
centers = scaler.inverse_transform(kmeans.cluster_centers_) # 스케일링된 중심점을 원본 스케일로 되돌림
plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.8, marker='X', label='Centroids')

plt.title(f'K-Means 고객 군집화 결과 (K={optimal_k})')
plt.legend()
plt.grid(True)
plt.show()

# 각 군집의 통계적 특성 분석
print("\n[각 군집별 특성 분석]")
cluster_summary = df.groupby('cluster').agg({
    '연간_총_구매금액': ['mean', 'min', 'max'],
    '연간_사이트_방문횟수': ['mean', 'min', 'max'],
    'cluster': 'count'
})
print(cluster_summary)

print("""
[해석 및 마케팅 전략 제안]
- Cluster 0: 구매액과 방문횟수 모두 보통 수준. (충성고객 후보군) -> 쿠폰/포인트로 구매 유도
- Cluster 1: 구매액은 낮으나 방문이 매우 잦음. (알뜰 쇼핑객/아이쇼핑 그룹) -> 저가 상품/타임딜 추천
- Cluster 2: 구매액은 높으나 방문이 적음. (우량고객/큰 손 그룹) -> VIP 전용 혜택, 신상품 우선 안내
- Cluster 3: 구매액과 방문횟수 모두 낮음. (비활성/신규 고객 그룹) -> 재방문 유도 웰컴 쿠폰, 관심사 설문
""")