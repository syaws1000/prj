'''
# 로지스틱 회귀란?
1. 도입
    로지스틱 회귀라는 이름은 조금 어렵지만, 사실은 O 아니면 X를 맞추는 똑똑한 예측 기계라고 생각하면
    쉽습니다.
    예를 들어, 컴퓨터에게 이런 문제를 내는 겁니다.
    - 이 사진은 강아지일 때, 고양이일까?
    - 내일은 비가 올까, 안 올까?
    - 공부를 이만큼 하면 시험에 합격할까? 불합격할까?
    로직스틱 회귀는 이런 두 가지 선택 문제에서 음 이건 합격일 확률이 80%정도 되겠는데?
    하고 정답일 확률을 알려주는 똑똑한 친구입니다.
2. 개요
    로직스틱 회귀(Logistic Regression)는 데이터가 특정 범주에 속할 확률을 예측하는 강력한
    분류(Classification)알고리즘입니다. 예/아니오, 합격/불합격, 정상/불량과 같이 두 가지
    결과 중 하나를 예측하는 이진 분류(Binary Classification)에 주로 사용됩니다.

    이를 회귀라는 단어가 있지만, 실제는 분류를 위한 알고리즘입니다. 선형 회귀처럼 데이터의 관계를
    모델링하되, 그  결과를 시그모이드 함수(Sigmoid function)에 통과시켜 0과 1사이의 확률값으로
    변환하는 것이 핵심입니다.
3. 핵심 개념
    1) 시그모이드 함수
        선형 방정식의 결과값(z)을 0과 1사이의 확률값으로 변환해주는 비선형 함수입니다.
        입력값이 아무리 크거나 작아도 출력값을 0과 1사이에 위치하는 S자 형태의 곡선을 가집니다.
        이 함수를 통해 이 데이터가 클래스 1(예:합격)에 속할 확률을 계산할 수 있습니다.
        예를 들어, 함수 출력이 0.8이라면 해당 데이터가 클래스 1에 속할 확률이 80%라는 의미입니다.
    2) 결정 경계
        결정 경계는 모델이 두 클래스를 구분하는 기준선입니다. 시그모이드 함수를 통해 계산된
        확률값이 특정 임계값보다 크며 클래스 1, 작으면 클래스 0으로 분류합니다.
        일반적으로 이 임계값이 0.5를 설정합니다. 즉, 확률이 50%를 넘으면 합격, 넘지 않으면
        불합격으로 판단하는 경계선이 생기는 겁입니다. 데잍의 특성에 따라 이 경계는
        직선일 수도 있고 곡선일 수도 있습니다.
    3) 확률
        로지스틱 회귀의 가장 큰 특징은 단순히 분류 결과(합격/불합격)만 알려주는 것이 아니라,
        그 결과에 대한 확률을 제공한다는 점입니다. 이는 모델의 예측이 얼마나 확실한지를
        알져주는 중요한 정보가 됩니다. 예를들어, A와 B 모두 합격으로 예측되더라도 A의
        합격 확률이 95%, B의 합격 확률이 55%라면 모델은 A의 합격을 훨씬 더 확신하고 
        있는 것입니다.

# 마법의 S자 규칙(코드)
1. 이 똑똑한 기계는 어떻게 합격할 확률을 알아낼까요? 바로 마법의 S자 모양 규칙을 이용합니다.
2. 시험 합격/불합격 문제로 생각해 봅시다.
    1) 공부를 쪼금만 하변? 합격할 확률이 아주 낮아요(S선의 왼쪽 아래)
    2) 공부를 아주 많이 하면 합격할 확률이 아주 높아요(S선의 오른쪽 위)
    3) 어중간하게 공부하면 공부를 조금만 더 해도 합격 확률이 쑥쑥 올라가요
3. 로지스틱 회귀는 데이터들을 보고, 이런 규칙을 가장 잘 설명하는 딱 맞는 S자 모양의 선(-시그모이드 함수로)을 스스로 찾아냅답니다.
   그리고, 우리는 보통 합격 확률이 50%를 넘으면 합격이라고 결정합니다. 이 50% 선이 합격과 불합격을 나누는 기준선이 되는 접니다.
'''
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression

# 1. 데이터 만들기(컴퓨터에게 줄 문제지와 정답)
# 공부 시간(문제지)
hours_studied = np.array([0.5, 0.75, 1, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.75, 4]).reshape(-1,1)
# 결과 (정답지) : 0은 불합격, 1은 합격
pass_fail = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1])

# 2. 로지스틱 회귀 모델 학습시키기(기계에서 규칙을 배우게 하기)
#    합격/불합격 예측 기계
model = LogisticRegression()
#    컴퓨터에게 데이터(공부 시간과 결과)를 보여주고 S자 규칙을 스스로 배우게 합니다.
model.fit(hours_studied, pass_fail)
# 3. 결과 그래프로 그래기(컴퓨터 배운 것을 눈으로 확인하기)
#  모델이 예측한 S자 모양의 합격 확률 선을 그려봅니다.
X_test = np.linspace(0,6,300).reshape(-1,1) # 0시간 부터 6시간까지 촘촘하게 점을 찍어요
y_prob = model.predict_proba(X_test)[:,1] # 각 시간에 대한 합격 확률을 계산

plt.rc('font', family='Malgun Gothic')

# 실제 데이터를 파란 점으로 찍어요
plt.scatter(hours_studied,pass_fail, color="blue", label="실제 데이터(0:불합격, 1:합격)")
# 모델이 학습한 S자 모양의 확률 선을 빨간색으로 그려요
plt.plot(X_test, y_prob, color="red", linewidth=3, label="예측한 합격 확률(마법의 S선)")
# 50% 기준선을 초록새 점선으로 그려요
plt.axhline(y=0.5, color="green", linestyle="--", label="합격/불합격 결정 기준 (50%)")

# 그래프 제목과 설명
plt.title("공부 시간에 따른 시험 합격 확률 예측")
plt.xlabel("공부할 시간")
plt.ylabel("합격 확률")
plt.legend()
plt.grid(True)
plt.show()

# 새로운 데이터로 예측해 보기(새로운 문제 풀어보기)
# 만약 2.8시간 공부했다면 합격할 수 있을까?
study_time_new = np.array([[2.8]])
# 먼저 합격할 '확률'을 물어봐요
pass_probability = model.predict_proba(study_time_new)[:,1]
# 그 다음 최종 결과 (합격/불합격)을 물어봐요
prediction = model.predict(study_time_new)
print(f'만약 {study_time_new[0][0]}시간 공부한다면...')
print(f"합격할 확률은 약 {pass_probability[0]*100:.2f}%입니다.")
print(f"최종 예측 결과: {'합격' if prediction[0] == 1 else '불합격'}")


'''
a05_logisticRegExp.py

캐릭터의 레벨에 따라 몬서터를 잡기 성공/실패여부 처리 하여 로직스틱 회기로 처리하고..
레벨 29일때, 성공/실패여부를 출력 하세요..

 특징(X): [캐릭터 레벨] (2차원 배열 형태로 만듭니다)
character_levels = np.array([
    [10], [12], [15], [20], # 패배한 그룹
    [30], [35], [40], [45]  # 승리한 그룹
])
# 결과(y): 0=패배, 1=승리
hunting_outcomes = np.array([0, 0, 0, 0, 1, 1, 1, 1])

'''





